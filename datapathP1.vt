// Copyright (C) 1991-2013 Altera Corporation
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, Altera MegaCore Function License 
// Agreement, or other applicable license agreement, including, 
// without limitation, that your use is for the sole purpose of 
// programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the 
// applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench template that is freely editable to  
// suit user's needs .Comments are provided in each section to help the user    
// fill out necessary details.                                                  
// *****************************************************************************
// Generated on "03/14/2017 22:27:23"
                                                                                
// Verilog Test Bench template for design : datapath
// 
// Simulation tool : ModelSim-Altera (Verilog)
// 

`timescale 1 ps/ 1 ps
module datapath_vlg_tst();
// constants                                           
// general purpose registers
reg eachvec;
// test vector input registers
reg [3:0] ALU_signals;
reg Bus_select_C;
reg Bus_select_HI;
reg Bus_select_INPort;
reg Bus_select_LO;
reg Bus_select_MDR;
reg Bus_select_PC;
reg Bus_select_R0;
reg Bus_select_R1;
reg Bus_select_R2;
reg Bus_select_R3;
reg Bus_select_R4;
reg Bus_select_R5;
reg Bus_select_R6;
reg Bus_select_R7;
reg Bus_select_R8;
reg Bus_select_R9;
reg Bus_select_R10;
reg Bus_select_R11;
reg Bus_select_R12;
reg Bus_select_R13;
reg Bus_select_R14;
reg Bus_select_R15;
reg Bus_select_Zhi;
reg Bus_select_Zlo;
reg HI_write_enable;
reg IR_write_enable;
reg InPort_write_enable;
reg LO_write_enable;
reg MAR_write_enable;
reg MDR_write_enable;
reg [31:0] Mdata_in;
reg Mem_read;
reg Mem_write;
reg OutPort_write_enable;
reg PC_write_enable;
reg R0_write_enable;
reg R1_write_enable;
reg R2_write_enable;
reg R3_write_enable;
reg R4_write_enable;
reg R5_write_enable;
reg R6_write_enable;
reg R7_write_enable;
reg R8_write_enable;
reg R9_write_enable;
reg R10_write_enable;
reg R11_write_enable;
reg R12_write_enable;
reg R13_write_enable;
reg R14_write_enable;
reg R15_write_enable;
reg Y_write_enable;
reg Z_write_enable;
reg Zhi_write_enable;
reg Zlo_write_enable;
reg clk;
reg reset;
// wires                                               
wire [31:0]  Bus;
wire [31:0]  Maddress_out;
wire [31:0]  Mdata_out;

// assign statements (if any)                          
datapath i1 (
// port map - connection between master ports and signals/registers   
	.ALU_signals(ALU_signals),
	.Bus(Bus),
	.Bus_select_C(Bus_select_C),
	.Bus_select_HI(Bus_select_HI),
	.Bus_select_INPort(Bus_select_INPort),
	.Bus_select_LO(Bus_select_LO),
	.Bus_select_MDR(Bus_select_MDR),
	.Bus_select_PC(Bus_select_PC),
	.Bus_select_R0(Bus_select_R0),
	.Bus_select_R1(Bus_select_R1),
	.Bus_select_R2(Bus_select_R2),
	.Bus_select_R3(Bus_select_R3),
	.Bus_select_R4(Bus_select_R4),
	.Bus_select_R5(Bus_select_R5),
	.Bus_select_R6(Bus_select_R6),
	.Bus_select_R7(Bus_select_R7),
	.Bus_select_R8(Bus_select_R8),
	.Bus_select_R9(Bus_select_R9),
	.Bus_select_R10(Bus_select_R10),
	.Bus_select_R11(Bus_select_R11),
	.Bus_select_R12(Bus_select_R12),
	.Bus_select_R13(Bus_select_R13),
	.Bus_select_R14(Bus_select_R14),
	.Bus_select_R15(Bus_select_R15),
	.Bus_select_Zhi(Bus_select_Zhi),
	.Bus_select_Zlo(Bus_select_Zlo),
	.HI_write_enable(HI_write_enable),
	.IR_write_enable(IR_write_enable),
	.InPort_write_enable(InPort_write_enable),
	.LO_write_enable(LO_write_enable),
	.MAR_write_enable(MAR_write_enable),
	.MDR_write_enable(MDR_write_enable),
	.Maddress_out(Maddress_out),
	.Mdata_in(Mdata_in),
	.Mdata_out(Mdata_out),
	.Mem_read(Mem_read),
	.Mem_write(Mem_write),
	.OutPort_write_enable(OutPort_write_enable),
	.PC_write_enable(PC_write_enable),
	.R0_write_enable(R0_write_enable),
	.R1_write_enable(R1_write_enable),
	.R2_write_enable(R2_write_enable),
	.R3_write_enable(R3_write_enable),
	.R4_write_enable(R4_write_enable),
	.R5_write_enable(R5_write_enable),
	.R6_write_enable(R6_write_enable),
	.R7_write_enable(R7_write_enable),
	.R8_write_enable(R8_write_enable),
	.R9_write_enable(R9_write_enable),
	.R10_write_enable(R10_write_enable),
	.R11_write_enable(R11_write_enable),
	.R12_write_enable(R12_write_enable),
	.R13_write_enable(R13_write_enable),
	.R14_write_enable(R14_write_enable),
	.R15_write_enable(R15_write_enable),
	.Y_write_enable(Y_write_enable),
	.Z_write_enable(Z_write_enable),
	.Zhi_write_enable(Zhi_write_enable),
	.Zlo_write_enable(Zlo_write_enable),
	.clk(clk),
	.reset(reset)
);
initial                                                
begin                                                  
// code that executes only once                        
// insert code here --> begin  
//init
	ALU_signals = 4'b1111;
	Mdata_in = 32'h00000000;
	Bus_select_C = 0; Bus_select_HI = 0; Bus_select_INPort = 0; Bus_select_LO = 0; Bus_select_MDR = 0; Bus_select_PC = 0; Bus_select_Zhi = 0; Bus_select_Zlo = 0;
	Bus_select_R0 = 0; Bus_select_R1 = 0; Bus_select_R2 = 0; Bus_select_R3 = 0; Bus_select_R4 = 0; Bus_select_R5 = 0; Bus_select_R6 = 0; Bus_select_R7 = 0;
	Bus_select_R8 = 0; Bus_select_R9 = 0; Bus_select_R10 = 0; Bus_select_R11 = 0; Bus_select_R12 = 0; Bus_select_R13 = 0; Bus_select_R14 = 0; Bus_select_R15 = 0;
	HI_write_enable = 0; IR_write_enable = 0; InPort_write_enable = 0; LO_write_enable = 0; MAR_write_enable = 0; MDR_write_enable = 0; OutPort_write_enable = 0; PC_write_enable = 0;
	R0_write_enable = 0; R1_write_enable = 0; R2_write_enable = 0; R3_write_enable = 0; R4_write_enable = 0; R5_write_enable = 0; R6_write_enable = 0; R7_write_enable = 0; 
	R8_write_enable = 0; R9_write_enable = 0; R10_write_enable = 0; R11_write_enable = 0; R12_write_enable = 0; R13_write_enable = 0; R14_write_enable = 0; R15_write_enable = 0;
	Y_write_enable = 0; Z_write_enable = 0; Zhi_write_enable = 0; Zlo_write_enable = 0;
	Mem_read = 0;
	Mem_write = 0;
	clk = 0;
	reset =1;

	@ (negedge clk);
		reset = 0;
	
	//trasfer value into r1
	@ (negedge clk);
		Mdata_in = 32'h00001111;
		Mem_read = 1;
		MDR_write_enable = 1;
		#15
		Mem_read = 0;
		MDR_write_enable = 0;		
		
	@ (negedge clk);	
		Bus_select_MDR = 1;
		R1_write_enable = 1;
		#15
		Bus_select_MDR = 0;
		R1_write_enable = 0;		


                        
                                                       
// --> end                                             
$display("Running testbench");                       
end                                                    
always                                                 
// optional sensitivity list                           
// @(event1 or event2 or .... eventn)                  
begin                                                  
// code executes for every event on sensitivity list   
// insert code here --> begin                          
	forever begin
		#10 clk = !clk;
	end                                               
@eachvec;                                              
// --> end                                             
end                                                    
endmodule

